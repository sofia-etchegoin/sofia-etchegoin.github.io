{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _executeFetch, _updateStaleTimeout, _computeRefetchInterval, _updateRefetchInterval, _updateTimers, _clearStaleTimeout, _clearRefetchInterval, _updateQuery, _notify;\n// src/queryObserver.ts\nimport { isServer, isValidTimeout, noop, replaceData, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { canFetch } from \"./retryer.js\";\nvar QueryObserver = (_client = /*#__PURE__*/new WeakMap(), _currentQuery = /*#__PURE__*/new WeakMap(), _currentQueryInitialState = /*#__PURE__*/new WeakMap(), _currentResult = /*#__PURE__*/new WeakMap(), _currentResultState = /*#__PURE__*/new WeakMap(), _currentResultOptions = /*#__PURE__*/new WeakMap(), _selectError = /*#__PURE__*/new WeakMap(), _selectFn = /*#__PURE__*/new WeakMap(), _selectResult = /*#__PURE__*/new WeakMap(), _lastQueryWithDefinedData = /*#__PURE__*/new WeakMap(), _staleTimeoutId = /*#__PURE__*/new WeakMap(), _refetchIntervalId = /*#__PURE__*/new WeakMap(), _currentRefetchInterval = /*#__PURE__*/new WeakMap(), _trackedProps = /*#__PURE__*/new WeakMap(), _executeFetch = /*#__PURE__*/new WeakSet(), _updateStaleTimeout = /*#__PURE__*/new WeakSet(), _computeRefetchInterval = /*#__PURE__*/new WeakSet(), _updateRefetchInterval = /*#__PURE__*/new WeakSet(), _updateTimers = /*#__PURE__*/new WeakSet(), _clearStaleTimeout = /*#__PURE__*/new WeakSet(), _clearRefetchInterval = /*#__PURE__*/new WeakSet(), _updateQuery = /*#__PURE__*/new WeakSet(), _notify = /*#__PURE__*/new WeakSet(), class QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    _classPrivateMethodInitSpec(this, _notify);\n    _classPrivateMethodInitSpec(this, _updateQuery);\n    _classPrivateMethodInitSpec(this, _clearRefetchInterval);\n    _classPrivateMethodInitSpec(this, _clearStaleTimeout);\n    _classPrivateMethodInitSpec(this, _updateTimers);\n    _classPrivateMethodInitSpec(this, _updateRefetchInterval);\n    _classPrivateMethodInitSpec(this, _computeRefetchInterval);\n    _classPrivateMethodInitSpec(this, _updateStaleTimeout);\n    _classPrivateMethodInitSpec(this, _executeFetch);\n    _classPrivateFieldInitSpec(this, _client, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentQuery, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentQueryInitialState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentResult, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentResultState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentResultOptions, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _selectError, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _selectFn, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _selectResult, {\n      writable: true,\n      value: void 0\n    });\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    _classPrivateFieldInitSpec(this, _lastQueryWithDefinedData, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _staleTimeoutId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _refetchIntervalId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _currentRefetchInterval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _trackedProps, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _currentQuery, void 0);\n    _classPrivateFieldSet(this, _currentQueryInitialState, void 0);\n    _classPrivateFieldSet(this, _currentResult, void 0);\n    _classPrivateFieldSet(this, _trackedProps, /* @__PURE__ */new Set());\n    _classPrivateFieldSet(this, _client, client);\n    this.options = options;\n    _classPrivateFieldSet(this, _selectError, null);\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      _classPrivateFieldGet(this, _currentQuery).addObserver(this);\n      if (shouldFetchOnMount(_classPrivateFieldGet(this, _currentQuery), this.options)) {\n        _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n      } else {\n        this.updateResult();\n      }\n      _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnReconnect);\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnWindowFocus);\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n    _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n    _classPrivateFieldGet(this, _currentQuery).removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = _classPrivateFieldGet(this, _currentQuery);\n    this.options = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      _classPrivateFieldGet(this, _client).getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: _classPrivateFieldGet(this, _currentQuery),\n        observer: this\n      });\n    }\n    if (typeof this.options.enabled !== \"undefined\" && typeof this.options.enabled !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean\");\n    }\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n    _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(_classPrivateFieldGet(this, _currentQuery), prevQuery, this.options, prevOptions)) {\n      _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n    }\n    const nextRefetchInterval = _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this);\n    if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== _classPrivateFieldGet(this, _currentRefetchInterval))) {\n      _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      _classPrivateFieldSet(this, _currentResult, result);\n      _classPrivateFieldSet(this, _currentResultOptions, this.options);\n      _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return _classPrivateFieldGet(this, _currentResult);\n  }\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          _classPrivateFieldGet(this, _trackedProps).add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  getCurrentQuery() {\n    return _classPrivateFieldGet(this, _currentQuery);\n  }\n  refetch() {\n    let {\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n    const query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n    return _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this, {\n      ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) !== null && _fetchOptions$cancelR !== void 0 ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return _classPrivateFieldGet(this, _currentResult);\n    });\n  }\n  createResult(query, options) {\n    const prevQuery = _classPrivateFieldGet(this, _currentQuery);\n    const prevOptions = this.options;\n    const prevResult = _classPrivateFieldGet(this, _currentResult);\n    const prevResultState = _classPrivateFieldGet(this, _currentResultState);\n    const prevResultOptions = _classPrivateFieldGet(this, _currentResultOptions);\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : _classPrivateFieldGet(this, _currentQueryInitialState);\n    const {\n      state\n    } = query;\n    let {\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? \"fetching\" : \"paused\";\n        if (!state.dataUpdatedAt) {\n          status = \"pending\";\n        }\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        fetchStatus = \"idle\";\n      }\n    }\n    if (options.select && typeof state.data !== \"undefined\") {\n      if (prevResult && state.data === (prevResultState === null || prevResultState === void 0 ? void 0 : prevResultState.data) && options.select === _classPrivateFieldGet(this, _selectFn)) {\n        data = _classPrivateFieldGet(this, _selectResult);\n      } else {\n        try {\n          _classPrivateFieldSet(this, _selectFn, options.select);\n          data = options.select(state.data);\n          data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, data, options);\n          _classPrivateFieldSet(this, _selectResult, data);\n          _classPrivateFieldSet(this, _selectError, null);\n        } catch (selectError) {\n          _classPrivateFieldSet(this, _selectError, selectError);\n        }\n      }\n    } else {\n      data = state.data;\n    }\n    if (typeof options.placeholderData !== \"undefined\" && typeof data === \"undefined\" && status === \"pending\") {\n      let placeholderData;\n      if (prevResult !== null && prevResult !== void 0 && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions === null || prevResultOptions === void 0 ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        var _classPrivateFieldGet2;\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_classPrivateFieldGet2 = _classPrivateFieldGet(this, _lastQueryWithDefinedData)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.state.data, _classPrivateFieldGet(this, _lastQueryWithDefinedData)) : options.placeholderData;\n        if (options.select && typeof placeholderData !== \"undefined\") {\n          try {\n            placeholderData = options.select(placeholderData);\n            _classPrivateFieldSet(this, _selectError, null);\n          } catch (selectError) {\n            _classPrivateFieldSet(this, _selectError, selectError);\n          }\n        }\n      }\n      if (typeof placeholderData !== \"undefined\") {\n        status = \"success\";\n        data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n    if (_classPrivateFieldGet(this, _selectError)) {\n      error = _classPrivateFieldGet(this, _selectError);\n      data = _classPrivateFieldGet(this, _selectResult);\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const result = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = _classPrivateFieldGet(this, _currentResult);\n    const nextResult = this.createResult(_classPrivateFieldGet(this, _currentQuery), this.options);\n    _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n    _classPrivateFieldSet(this, _currentResultOptions, this.options);\n    if (_classPrivateFieldGet(this, _currentResultState).data !== void 0) {\n      _classPrivateFieldSet(this, _lastQueryWithDefinedData, _classPrivateFieldGet(this, _currentQuery));\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _currentResult, nextResult);\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !_classPrivateFieldGet(this, _trackedProps).size) {\n        return true;\n      }\n      const includedProps = new Set(notifyOnChangePropsValue !== null && notifyOnChangePropsValue !== void 0 ? notifyOnChangePropsValue : _classPrivateFieldGet(this, _trackedProps));\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(_classPrivateFieldGet(this, _currentResult)).some(key => {\n        const typedKey = key;\n        const changed = _classPrivateFieldGet(this, _currentResult)[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if ((notifyOptions === null || notifyOptions === void 0 ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    _classPrivateMethodGet(this, _notify, _notify2).call(this, {\n      ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n    }\n  }\n});\nfunction _executeFetch2(fetchOptions) {\n  _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n  let promise = _classPrivateFieldGet(this, _currentQuery).fetch(this.options, fetchOptions);\n  if (!(fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n}\nfunction _updateStaleTimeout2() {\n  _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n  if (isServer || _classPrivateFieldGet(this, _currentResult).isStale || !isValidTimeout(this.options.staleTime)) {\n    return;\n  }\n  const time = timeUntilStale(_classPrivateFieldGet(this, _currentResult).dataUpdatedAt, this.options.staleTime);\n  const timeout = time + 1;\n  _classPrivateFieldSet(this, _staleTimeoutId, setTimeout(() => {\n    if (!_classPrivateFieldGet(this, _currentResult).isStale) {\n      this.updateResult();\n    }\n  }, timeout));\n}\nfunction _computeRefetchInterval2() {\n  var _ref;\n  return (_ref = typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(_classPrivateFieldGet(this, _currentQuery)) : this.options.refetchInterval) !== null && _ref !== void 0 ? _ref : false;\n}\nfunction _updateRefetchInterval2(nextInterval) {\n  _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n  _classPrivateFieldSet(this, _currentRefetchInterval, nextInterval);\n  if (isServer || this.options.enabled === false || !isValidTimeout(_classPrivateFieldGet(this, _currentRefetchInterval)) || _classPrivateFieldGet(this, _currentRefetchInterval) === 0) {\n    return;\n  }\n  _classPrivateFieldSet(this, _refetchIntervalId, setInterval(() => {\n    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n    }\n  }, _classPrivateFieldGet(this, _currentRefetchInterval)));\n}\nfunction _updateTimers2() {\n  _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n  _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this));\n}\nfunction _clearStaleTimeout2() {\n  if (_classPrivateFieldGet(this, _staleTimeoutId)) {\n    clearTimeout(_classPrivateFieldGet(this, _staleTimeoutId));\n    _classPrivateFieldSet(this, _staleTimeoutId, void 0);\n  }\n}\nfunction _clearRefetchInterval2() {\n  if (_classPrivateFieldGet(this, _refetchIntervalId)) {\n    clearInterval(_classPrivateFieldGet(this, _refetchIntervalId));\n    _classPrivateFieldSet(this, _refetchIntervalId, void 0);\n  }\n}\nfunction _updateQuery2() {\n  const query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), this.options);\n  if (query === _classPrivateFieldGet(this, _currentQuery)) {\n    return;\n  }\n  const prevQuery = _classPrivateFieldGet(this, _currentQuery);\n  _classPrivateFieldSet(this, _currentQuery, query);\n  _classPrivateFieldSet(this, _currentQueryInitialState, query.state);\n  if (this.hasListeners()) {\n    prevQuery === null || prevQuery === void 0 || prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n}\nfunction _notify2(notifyOptions) {\n  notifyManager.batch(() => {\n    if (notifyOptions.listeners) {\n      this.listeners.forEach(listener => {\n        listener(_classPrivateFieldGet(this, _currentResult));\n      });\n    }\n    _classPrivateFieldGet(this, _client).getQueryCache().notify({\n      query: _classPrivateFieldGet(this, _currentQuery),\n      type: \"observerResultsUpdated\"\n    });\n  });\n}\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport { QueryObserver };","map":{"version":3,"names":["isServer","isValidTimeout","noop","replaceData","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","canFetch","QueryObserver","_client","WeakMap","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","_executeFetch","WeakSet","_updateStaleTimeout","_computeRefetchInterval","_updateRefetchInterval","_updateTimers","_clearStaleTimeout","_clearRefetchInterval","_updateQuery","_notify","constructor","client","options","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","Set","bindMethods","setOptions","refetch","bind","onSubscribe","listeners","size","_classPrivateFieldGet","addObserver","shouldFetchOnMount","_classPrivateMethodGet","_executeFetch2","call","updateResult","_updateTimers2","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","_clearStaleTimeout2","_clearRefetchInterval2","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","getQueryCache","notify","type","query","observer","enabled","Error","queryKey","_updateQuery2","mounted","shouldFetchOptionally","staleTime","_updateStaleTimeout2","nextRefetchInterval","_computeRefetchInterval2","_updateRefetchInterval2","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","arguments","length","undefined","fetch","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","error","errorUpdatedAt","fetchStatus","status","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","networkMode","dataUpdatedAt","select","selectError","placeholderData","_classPrivateFieldGet2","Date","now","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","some","typedKey","changed","has","_notify2","onQueryUpdate","promise","catch","time","timeout","setTimeout","_ref","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","batch","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","optimisticResult"],"sources":["/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch } from './retryer'\nimport type { QueryClient } from './queryClient'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps: Set<keyof QueryObserverResult> = new Set()\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.options = options\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.#updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.#currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let { error, errorUpdatedAt, fetchStatus, status } = state\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!state.dataUpdatedAt) {\n          status = 'pending'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}