{"ast":null,"code":"// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode !== null && networkMode !== void 0 ? networkMode : \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class {\n  constructor(options) {\n    this.revert = options === null || options === void 0 ? void 0 : options.revert;\n    this.silent = options === null || options === void 0 ? void 0 : options.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      var _config$abort;\n      reject(new CancelledError(cancelOptions));\n      (_config$abort = config.abort) === null || _config$abort === void 0 || _config$abort.call(config);\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== \"always\" && !onlineManager.isOnline();\n  const resolve = value => {\n    if (!isResolved) {\n      var _config$onSuccess, _continueFn;\n      isResolved = true;\n      (_config$onSuccess = config.onSuccess) === null || _config$onSuccess === void 0 || _config$onSuccess.call(config, value);\n      (_continueFn = continueFn) === null || _continueFn === void 0 || _continueFn();\n      promiseResolve(value);\n    }\n  };\n  const reject = value => {\n    if (!isResolved) {\n      var _config$onError, _continueFn2;\n      isResolved = true;\n      (_config$onError = config.onError) === null || _config$onError === void 0 || _config$onError.call(config, value);\n      (_continueFn2 = continueFn) === null || _continueFn2 === void 0 || _continueFn2();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise(continueResolve => {\n      var _config$onPause;\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n        if (canContinue) {\n          continueResolve(value);\n        }\n        return canContinue;\n      };\n      (_config$onPause = config.onPause) === null || _config$onPause === void 0 || _config$onPause.call(config);\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        var _config$onContinue;\n        (_config$onContinue = config.onContinue) === null || _config$onContinue === void 0 || _config$onContinue.call(config);\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay, _config$onFail;\n      if (isResolved) {\n        return;\n      }\n      const retry = (_config$retry = config.retry) !== null && _config$retry !== void 0 ? _config$retry : isServer ? 0 : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) !== null && _config$retryDelay !== void 0 ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      (_config$onFail = config.onFail) === null || _config$onFail === void 0 || _config$onFail.call(config, failureCount, error);\n      sleep(delay).then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      var _continueFn3;\n      const didContinue = (_continueFn3 = continueFn) === null || _continueFn3 === void 0 ? void 0 : _continueFn3();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"names":["focusManager","onlineManager","isServer","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","_config$abort","reject","abort","call","cancelRetry","continueRetry","shouldPause","isFocused","resolve","_config$onSuccess","_continueFn","onSuccess","_config$onError","_continueFn2","onError","pause","continueResolve","_config$onPause","canContinue","onPause","then","_config$onContinue","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","_config$onFail","retry","retryDelay","delay","shouldRetry","onFail","continue","_continueFn3","didContinue"],"sources":["/Users/sofiaetchegoin/Documents/devacademy/bootcamp/welcome/node_modules/@tanstack/query-core/src/retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}